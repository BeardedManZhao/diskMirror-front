class DiskMirror{constructor(url){this.diskMirrorUrl=url;this.setSk();this.setController('/FsCrud')}xorEncrypt(value){let encrypted=value;const sk_str=this.sk.toString();for(let i=0;i<sk_str.length;i++){encrypted-=sk_str.charCodeAt(i)<<1}return encrypted}setController(controllerName){this.controller=controllerName}getController(){return this.controller}setSk(key=0,domain=undefined){this.sk=key;if(key!==0){this.setDiskMirrorXorSecureKey(domain)}}getSk(){return this.sk}upload(params,file,okFun=undefined,errorFun=(e)=>'res'in e?alert(e['res']):alert(e),checkFun=undefined){if(checkFun!==undefined&&!checkFun(params,file)){return}const formData=new FormData();params["secure.key"]=this.getSk();const blob=new Blob([JSON.stringify(params)],{type:'application/json'});formData.append('params',blob,"params");formData.append('file',file,"file");axios.defaults.withCredentials=true;axios({method:'post',url:this.diskMirrorUrl+this.getController()+'/add',data:formData,headers:{'Content-Type':'multipart/form-data'}}).then(function(res){if(res.data['res']!=='ok!!!!'){if(errorFun!==undefined){errorFun(res.data)}return}if(okFun!==undefined){okFun(res.data)}else{console.info(res.data)}}).catch(function(err){if(errorFun!==undefined){errorFun(err)}else{console.error(err)}})}getUrls(userId,type,okFun=undefined,errorFun=(e)=>'res'in e?alert(e['res']):alert(e),checkFun=undefined,){if(userId===undefined||type===undefined||type===''){const err="您必须要输入 userId 以及 type 参数才可以进行 url 的获取";if(errorFun!==undefined){errorFun(err)}else{console.error(err)}return}const formData=new FormData();const params={userId:userId,type:type,"secure.key":this.getSk()};if(checkFun!==undefined&&!checkFun(params)){return}const blob=new Blob([JSON.stringify(params)],{type:'application/json'});formData.append('params',blob,"params");axios.defaults.withCredentials=true;axios({method:'post',url:this.diskMirrorUrl+this.getController()+'/getUrls',data:formData,headers:{'Content-Type':'multipart/form-data'}}).then(function(res){if(res.data['res']!=='ok!!!!'){if(errorFun!==undefined){errorFun(res.data)}return}if(okFun!==undefined){okFun(res.data)}else{console.info(res.data)}}).catch(function(err){if(errorFun!==undefined){errorFun(err)}else{console.error(err)}})}remove(userId,type,fileName,okFun=undefined,errorFun=(e)=>'res'in e?alert(e['res']):alert(e),checkFun=undefined,){if(userId===undefined||type==null||type===''||fileName===undefined||fileName===''){const err="您必须要输入 userId 以及 type 和 fileName 参数才可以进行删除";if(errorFun!==undefined){errorFun(err)}else{console.error(err)}return}const formData=new FormData();const params={fileName:fileName,userId:userId,type:type,"secure.key":this.getSk()};if(checkFun!==undefined&&!checkFun(params)){return}const blob=new Blob([JSON.stringify(params)],{type:'application/json'});formData.append('params',blob,"params");axios.defaults.withCredentials=true;axios({method:'post',url:this.diskMirrorUrl+this.getController()+'/remove',data:formData,headers:{'Content-Type':'multipart/form-data'}}).then(function(res){if(res.data['res']!=='ok!!!!'){if(errorFun!==undefined){errorFun(res.data)}return}if(okFun!==undefined){okFun(res.data)}else{console.info(res.data)}}).catch(function(err){if(errorFun!==undefined){errorFun(err)}else{console.error(err)}})}reName(userId,type,fileName,newName,okFun=undefined,errorFun=(e)=>'res'in e?alert(e['res']):alert(e),checkFun=undefined){if(userId===undefined||type==null||type===''||fileName===undefined||fileName===''||newName===undefined||newName===''){const err="您必须要输入 userId 和 type 以及 fileName 和 newName 参数才可以进行重命名";if(errorFun!==undefined){errorFun(err)}else{console.error(err)}return}const formData=new FormData();const params={fileName:fileName,newName:newName,userId:userId,type:type,"secure.key":this.getSk()};if(checkFun!==undefined&&!checkFun(params)){return}const blob=new Blob([JSON.stringify(params)],{type:'application/json'});formData.append('params',blob,"params");axios.defaults.withCredentials=true;axios({method:'post',url:this.diskMirrorUrl+this.getController()+'/reName',data:formData,headers:{'Content-Type':'multipart/form-data'}}).then(function(res){if(res.data['res']!=='ok!!!!'){if(errorFun!==undefined){errorFun(res.data)}return}if(okFun!==undefined){okFun(res.data)}else{console.info(res.data)}}).catch(function(err){if(errorFun!==undefined){errorFun(err)}else{console.error(err)}})}mkdirs(userId,type,fileName,okFun=undefined,errorFun=(e)=>'res'in e?alert(e['res']):alert(e),checkFun=undefined){if(userId===undefined||type==null||type===''||fileName===undefined||fileName===''){const err="您必须要输入 userId 和 type 以及 fileName 参数才可以进行文件目录的创建";if(errorFun!==undefined){errorFun(err)}else{console.error(err)}return}const formData=new FormData();const params={fileName:fileName,userId:userId,type:type,"secure.key":this.getSk()};if(checkFun!==undefined&&!checkFun(params)){return}const blob=new Blob([JSON.stringify(params)],{type:'application/json'});formData.append('params',blob,"params");axios.defaults.withCredentials=true;axios({method:'post',url:this.diskMirrorUrl+this.getController()+'/mkdirs',data:formData,headers:{'Content-Type':'multipart/form-data'}}).then(function(res){if(res.data['res']!=='ok!!!!'){if(errorFun!==undefined){errorFun(res.data)}return}if(okFun!==undefined){okFun(res.data)}else{console.info(res.data)}}).catch(function(err){if(errorFun!==undefined){errorFun(err)}else{console.error(err)}})}downLoad(userId,type,fileName,okFun=undefined,errorFun=(e)=>'res'in e?alert(e['res']):alert(e),checkFun=undefined,version=1){if(userId===undefined||type==null||type===''||fileName===undefined||fileName===''||okFun===undefined){const err="您必须要输入 userId 和 type 以及 fileName 和 okFun 参数才可以进行文件对象的获取！";if(errorFun!==undefined){errorFun(err)}else{console.error(err)}return}if(checkFun!==undefined&&!checkFun({userId:userId,type:type,fileName:fileName})){return}okFun(version<2?this.diskMirrorUrl+this.getController()+`/downLoad/${userId}/${type}?fileName=${fileName}` : this.diskMirrorUrl + this.getController() + `/downLoad2/${userId}/${type}/${this.getSk()}/${fileName.startsWith('/') ? fileName.substring(1) : fileName}`);
}

    /**
     * 向后端中转存一个文件
     * @param params {{
     *      fileName: string,
     *      userId: int,
     *      type: 'Binary'|'TEXT',
     *      url: string
     * }} 这里是请求参数对象 其中的文件名字代表上传到后端之后的文件名字，userId 代表的就是文件要上传到的指定空间的id；type就是代表的文件的类型 支持二进制和文本两种格式
     * @param okFun {function} 操作成功之后的回调函数 输入是被上传文件的json对象
     * @param errorFun {function} 操作失败之后的回调函数 输入是错误信息
     * @param checkFun {function} 上传前的检查函数 输入是上传的文件对象的 json 数据 ，如果返回的是一个false 则代表不进行上传操作
     */
    transferDeposit(params, okFun = undefined, errorFun = (e) => 'res' in e ? alert(e['res']) : alert(e), checkFun = undefined) {
        if (checkFun !== undefined && !checkFun(params)) {
            return;
        }
        const formData = new FormData();
        // 设置请求参数数据包
        params["secure.key"] = this.getSk();
        const blob = new Blob([JSON.stringify(params)], {
            type: 'application/json'
        });
        formData.append('params', blob, "params");
        // 开始进行请求发送
        axios.defaults.withCredentials = true;
        axios(
            {
                method: 'post',
                url: this.diskMirrorUrl + this.getController() + '/transferDeposit',
                data: formData,
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }
        ).then(function (res) {
            if (res.data['res'] !== 'ok!!!!') {
                if (errorFun !== undefined) {
                    errorFun(res.data);
                }
                return;
            }
            // 处理成功
            if (okFun !== undefined) {
                okFun(res.data);
            } else {
                console.info(res.data);
            }
        }).catch(function (err) {
            // 处理错误
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
        });
    }

    /**
     * 向后端中查询文件转存情况
     * @param params {{
     *      userId: int,
     *      type: 'Binary'|'TEXT',
     * }} 这里是请求参数对象 其中的文件名字代表上传到后端之后的文件名字，userId 代表的就是文件要上传到的指定空间的id；type就是代表的文件的类型 支持二进制和文本两种格式
     * @param okFun {function} 操作成功之后的回调函数 输入是被上传文件的json对象
     * @param errorFun {function} 操作失败之后的回调函数 输入是错误信息
     * @param checkFun {function} 上传前的检查函数 输入是上传的文件对象的 json 数据 以及 文件对象本身，如果返回的是一个false 则代表不进行上传操作
     */
    transferDepositStatus(params, okFun = undefined, errorFun = (e) => 'res' in e ? alert(e['res']) : alert(e), checkFun = undefined) {
        if (checkFun !== undefined && !checkFun(params)) {
            return;
        }
        const formData = new FormData();
        // 设置请求参数数据包
        params["secure.key"] = this.getSk();
        const blob = new Blob([JSON.stringify(params)], {
            type: 'application/json'
        });
        formData.append('params', blob, "params");        // 开始进行请求发送
        axios.defaults.withCredentials = true;
        axios(
            {
                method: 'post',
                url: this.diskMirrorUrl + this.getController() + '/transferDepositStatus',
                data: formData,
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }
        ).then(function (res) {
            // 处理成功
            if (okFun !== undefined) {
                okFun(res.data);
            } else {
                console.info(res.data);
            }
        }).catch(function (err) {
            // 处理错误
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
        });
    }

    /**
     * 获取指定空间的最大容量 单位是 字节
     *
     * 需要确保远程的 diskMirror 服务器是在 2024年 2 月 17 日 以及之后发布的！！
     *
     * @param userId {int} 需要被检索的空间id
     * @param okFun {function} 操作成功之后的回调函数 输入是被创建的文件目录的json对象
     * @param errorFun {function} 操作失败之后的回调函数 输入是错误信息
     */
    getSpaceMaxSize(userId, okFun = undefined, errorFun = (e) => 'res' in e ? alert(e['res']) : alert(e)) {
        // 开始进行请求发送
        axios.defaults.withCredentials = true;
        axios(
            {
                method: 'post',
                url: this.diskMirrorUrl + this.getController() + '/getSpaceSize',
                params: {
                    spaceId: userId.toString()
                }
            }
        ).then(function (res) {
            const data = res.data;
            if (isNaN(data['res'])) {
                if (errorFun !== undefined) {
                    errorFun(data['res'] + " is NAN!!!");
                }
                return;
            }
            if (okFun !== undefined) {
                okFun(data['res']);
            } else {
                console.info(data['res']);
            }
        }).catch(function (err) {
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
        });
    }

    /**
     * 获取后端中的盘镜内核的版本
     *
     * 需要确保远程的 diskMirror 服务器是在 2024年 2 月 17 日 以及之后发布的！！
     *
     * @param okFun {function} 操作成功之后的回调函数 输入是被创建的文件目录的json对象
     * @param errorFun {function} 操作失败之后的回调函数 输入是错误信息
     */
    getVersion(okFun = undefined, errorFun = (e) => 'res' in e ? alert(e['res']) : alert(e)) {
        // 开始进行请求发送
        axios.defaults.withCredentials = true;
        axios(
            {
                method: 'post',
                url: this.diskMirrorUrl + this.getController() + '/getVersion',
            }
        ).then(function (res) {
            if (okFun !== undefined) {
                okFun(res.data);
            } else {
                console.info(res.data);
            }
        }).catch(function (err) {
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
        });
    }

    /**
     * 获取指定空间的已使用容量 单位是 字节
     * @param userId {int} 需要被检索的空间id
     * @param type {'Binary'|'TEXT'} 需要被检索的文件类型
     * @param okFun {function} 操作成功之后的回调函数 输入是计算出来的已使用容量
     * @param errorFun {function} 操作失败之后的回调函数 输入是错误信息
     */
    getUseSize(userId, type, okFun = undefined, errorFun = (e) => 'res' in e ? alert(e['res']) : alert(e)) {
        if (userId === undefined || type == null || type === '') {
            const err = "您必须要输入 userId 和 type 参数才可以进行使用数量的获取";
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
            return;
        }
        const formData = new FormData();
        // 设置请求参数
        const params = {
            userId: userId,
            type: type,
            "secure.key": this.getSk()
        };
        const blob = new Blob([JSON.stringify(params)], {
            type: 'application/json'
        });
        formData.append('params', blob, "params");

        // 开始进行请求发送
        axios.defaults.withCredentials = true;
        axios(
            {
                method: 'post',
                url: this.diskMirrorUrl + this.getController() + '/getUseSize',
                data: formData,
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }
        ).then(function (res) {
            if (okFun !== undefined) {
                okFun(res.data);
            } else {
                console.info(res.data);
            }
        }).catch(function (err) {
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
        });
    }

    /**
     * 在一些操作中，我们可能需要将 sk 包含在 cookie 中，因此可能会需要使用这个函数，这个函数一般来说不需要用户手动调用！
     *
     * 因为在设置好 sk 的时候，它会自动被调用！请勿随意修改此函数带来的cookie，某些后端服务会使用到！
     *
     * @param domain {string} 需要被设置的cookie的域名 默认是当前域
     */
    setDiskMirrorXorSecureKey(domain) {
        // 检查名为 diskMirror_xor_secure_key 的 cookie 是否存在
        const cookieName = 'diskMirror_xor_secure_key';
        // 如果存在就更新 cookie 的值
        const encryptedValue = this.xorEncrypt(this.getSk());
        if (this.isSetCookie && this.cookieValue === encryptedValue && this.cookieDoMain === domain) {
            // 如果设置过 cookie 且 值 和 域 相同 则这里就不继续更新 cookie 了
            return;
        }
        if (domain) {
            document.cookie = `${cookieName}=${encryptedValue};path=/;domain=${domain}`;
            return;
        }
        document.cookie = `${cookieName}=${encryptedValue};path=/`;
        // 标记 cookie 信息
        this.isSetCookie = true;
        this.cookieValue = encryptedValue;
        this.cookieDoMain = domain;
    }

    /**
     * 获取指定空间的所有的进度条
     * @param userId {int|string} 指定要获取到的文件进度数据对应的空间id
     * @param okFun {function} 操作成功之后的回调函数 输入是被文件进度的json对象
     * @param errorFun {function} 操作失败之后的回调函数 输入是错误信息
     * @param checkFun {function} 操作前的检查函数 输入是请求参数对象，如果返回的是一个false 则代表检查失败不继续操作
     */
    getAllProgressBar(userId, okFun = undefined, errorFun = (e) => 'res' in e ? alert(e['res']) : alert(e), checkFun = undefined) {
        if (userId === undefined || okFun === undefined) {
            const err = "您必须要输入 userId 和 okFun 参数才可以进行文件对象的获取！";
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
            return;
        }
        if (checkFun !== undefined && !checkFun(userId)) {
            return;
        }
        axios.defaults.withCredentials = true;
        // 开始获取
        axios(
            {
                method: 'post',
                url: this.diskMirrorUrl + this.getController() + '/getAllProgressBar',
                params: {
                    id: userId
                }
            }
        ).then(function (res) {
            // 处理成功
            if (okFun !== undefined) {
                okFun(res.data);
            } else {
                console.info(res.data);
            }
        }).catch(function (err) {
            // 处理错误
            if (errorFun !== undefined) {
                errorFun(err);
            } else {
                console.error(err);
            }
        });
    }

    /**
     * 将当前客户端连接的服务器关机（如果服务器端受支持的话，则会返回关机或有效信息）
     *
     * @param password {string} 关机操作的校验码，如果校验码不正确，则无法处理关机请求
     * @param okFun {function} 操作成功之后的回调函数 输入是被文件进度的json对象
     * @param errorFun {function} 操作失败之后的回调函数 输入是错误信息
     */
    shutdown(password, okFun = undefined, errorFun = (e) => 'res' in e ? alert(e['res']) : alert(e)) {
        axios.defaults.withCredentials = true;
        // 开始获取
        axios(
            {
                method: 'post',
                url: this.diskMirrorUrl + this.getController() + '/shutdown',params:{password:password}}).then(function(res){if(okFun!==undefined){okFun(res.data)}else{console.info(res.data)}}).catch(function(err){if(errorFun!==undefined){errorFun(err)}else{console.error(err)}})}}